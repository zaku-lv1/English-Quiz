<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SKYWARD (Auxiliary & Passive)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Noto+Sans+JP:wght@400;500;700&display=swap');
        body {
            font-family: 'Inter', 'Noto Sans JP', sans-serif;
        }
        .draggable-item {
            cursor: grab;
            user-select: none;
            touch-action: none;
        }
        .drop-zone {
            min-height: 50px;
            border-style: dashed;
        }
        .dragging {
            opacity: 0.5;
            background-color: #e0e7ff;
        }
        .touch-active {
            transform: scale(1.05);
            z-index: 1000;
            position: relative;
        }
        .drop-zone-hover {
            background-color: #f0f9ff;
            border-color: #3b82f6;
        }
    </style>
</head>
<body class="bg-slate-100 flex items-center justify-center min-h-screen p-4">

    <div id="quiz-container" class="w-full max-w-2xl bg-white rounded-xl shadow-lg p-6 md:p-8 transition-all duration-500">
        
        <div id="start-screen">
            <h1 class="text-2xl md:text-3xl font-bold text-slate-800 text-center mb-2">SKYWARD (Auxiliary & Passive)</h1>
            <p class="text-slate-600 text-center mb-8">助動詞と受動態の復習問題に挑戦してみよう！</p>
            <button id="start-btn" class="w-full bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-4 rounded-lg transition-transform transform hover:scale-105 focus:outline-none focus:ring-4 focus:ring-blue-300">
                クイズを始める (ランダム10問)
            </button>
        </div>

        <div id="quiz-screen" class="hidden">
            <!-- Header -->
            <div class="flex justify-between items-center mb-4">
                <div class="text-sm font-semibold text-slate-500">
                    <span id="question-counter"></span>
                </div>
                <div class="text-sm font-bold text-blue-500">
                    スコア: <span id="score">0</span>
                </div>
            </div>

            <!-- Progress Bar -->
            <div class="w-full bg-slate-200 rounded-full h-2.5 mb-6">
                <div id="progress-bar" class="bg-blue-500 h-2.5 rounded-full" style="width: 0%"></div>
            </div>

            <!-- Question -->
            <div class="mb-6">
                <p id="japanese-prompt" class="text-slate-600 text-center text-lg mb-3"></p>
                <div id="question-area" class="bg-slate-50 p-4 rounded-lg text-center text-xl font-medium text-slate-800">
                </div>
            </div>

            <!-- Options -->
            <div id="options-container" class="grid grid-cols-1 gap-3 mb-4">
                <!-- Options will be injected here -->
            </div>
            
             <!-- Scramble Area -->
            <div id="scramble-area" class="hidden">
                <div id="answer-zone" class="drop-zone border-2 border-slate-300 rounded-lg p-3 mb-3 flex flex-wrap gap-2 items-center bg-slate-50"></div>
                <p class="text-center text-sm text-slate-500 mb-3">下の単語をドラッグ＆ドロップして文を完成させてください。</p>
                <div id="word-bank" class="flex flex-wrap gap-2 justify-center p-3 bg-white rounded-lg border"></div>
            </div>


            <!-- Feedback -->
            <div id="feedback" class="text-center font-bold mt-4 p-3 rounded-lg hidden"></div>

            <!-- Next Button -->
            <button id="next-btn" class="w-full bg-slate-700 hover:bg-slate-800 text-white font-bold py-3 px-4 rounded-lg mt-4 transition-transform transform hover:scale-105 focus:outline-none focus:ring-4 focus:ring-slate-300 hidden">
                次へ
            </button>
        </div>
        
        <div id="result-screen" class="hidden text-center">
            <h2 class="text-2xl md:text-3xl font-bold text-slate-800 mb-4">クイズ終了！</h2>
            <p class="text-xl text-slate-600 mb-6">あなたのスコアは...</p>
            <div class="bg-blue-500 text-white rounded-full w-32 h-32 flex items-center justify-center mx-auto mb-6">
                <p class="text-4xl font-bold"><span id="final-score"></span> / <span id="total-questions"></span></p>
            </div>
            <p id="result-message" class="text-lg font-semibold mb-8"></p>
            <button id="restart-btn" class="w-full bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-4 rounded-lg transition-transform transform hover:scale-105 focus:outline-none focus:ring-4 focus:ring-blue-300">
                もう一度挑戦する
            </button>
        </div>

    </div>

    <script>
        const allQuizData = [
            // Stage 1, Lesson 2 (Auxiliary Verb 1)
            { type: 'mcq', japanese: '「彼は60歳を超えているはずがない。まだ40代のはずだ。」', question: 'He {blank} be over sixty; he must still be in his forties.', options: ["can't", 'may not', 'must not'], answer: "can't", explanation: '「〜のはずがない」という強い否定の推量を表すのは `can\'t` です。`must not` は「〜してはいけない」という禁止の意味になります。' },
            { type: 'mcq', japanese: '「海外へ行く時、いつもビザを取らなければなりませんか？」', question: 'When you go abroad, do you always {blank} get a visa?', options: ['must', 'have to', 'should'], answer: 'have to', explanation: '「〜しなければならない」という義務を表しますが、疑問文では `Do you have to...?` の形が一般的です。' },
            { type: 'mcq', japanese: '「このレポートは今すぐには必要ないので、すぐに提出する必要はありません。」', question: 'This report is not needed right now, so you {blank} turn it in immediately.', options: ['must not', "don't have to", 'need not to'], answer: "don't have to", explanation: '`don\'t have to` は「〜する必要はない」という意味です。`must not` は「〜してはいけない」という禁止になるので文脈に合いません。' },
            { type: 'mcq', japanese: '「もっと慎重に運転すべきですよ。」', question: 'You {blank} drive your car more carefully.', options: ['should', 'might', 'can'], answer: 'should', explanation: '「〜すべきだ」という助言や提案を表す `should` が適切です。' },
            { type: 'mcq', japanese: '「ジェーンは食べるよりはむしろ読書をしたい。」', question: 'Jane would {blank} read than eat.', options: ['rather', 'better', 'like'], answer: 'rather', explanation: '`would rather A than B` で「BするよりもむしろAしたい」という意味になります。' },
            { type: 'scramble', japanese: '「すみません、郵便局がどこにあるか教えていただけませんか。」', words: ['Excuse', 'me', ',', 'could', 'you', 'tell', 'me', 'where', 'the', 'post', 'office', 'is', '?'], answer: 'Excuse me, could you tell me where the post office is?', explanation: '`Could you...?` は `Can you...?` よりも丁寧な依頼の表現です。間接疑問文なので `where` 以下の語順は `the post office is` となります。' },
            
            // Stage 1, Lesson 2 (Auxiliary Verb 2)
            { type: 'mcq', japanese: '「タロウは昨日そこにいたかもしれないが、誰も彼に会わなかった。」', question: 'Taro {blank} there yesterday, but nobody saw him.', options: ['might have been', 'must be', 'should be'], answer: 'might have been', explanation: '過去の出来事に対する推量（〜だったかもしれない）は `might have + 過去分詞` で表します。' },
            { type: 'mcq', japanese: '「彼はもっと早く出発すべきだったのに。」', question: 'He {blank} earlier.', options: ['should have left', 'must have left', 'could leave'], answer: 'should have left', explanation: '`should have + 過去分詞` で、過去の行動に対する後悔や非難「〜すべきだったのに（しなかった）」を表します。' },
            { type: 'mcq', japanese: '「私は携帯電話をなくしてしまったに違いない。連絡先リストにアクセスできない。」', question: "I must {blank} my cell phone! I can't get to my contact list.", options: ['have lost', 'lose', 'be losing'], answer: 'have lost', explanation: '過去の出来事に対する強い確信（〜したに違いない）は `must have + 過去分詞` で表します。' },
            { type: 'mcq', japanese: '「とても緊張しましたが、その必要はありませんでした。試験はとても簡単でした。」', question: 'I got very nervous about the exam, but I {blank}. It was really easy.', options: ["needn't have", 'cannot have', "didn't need"], answer: "needn't have", explanation: '`needn\'t have + 過去分詞` で「〜する必要はなかったのに（してしまった）」という意味を表します。' },
            { type: 'scramble', japanese: '「彼にその知らせを伝える必要はなかったのに、あなたは伝えてしまった。」', words: ['You', 'need', 'not', 'have', 'told', 'him', 'the', 'news', '.'], answer: 'You need not have told him the news.', explanation: '`need not have + 過去分詞` で「〜する必要はなかったのに」という意味になります。' },
            { type: 'scramble', japanese: '「以前に彼に会ったことがあるかもしれませんが、どこだったか思い出せません。」', words: ['I', 'may', 'have', 'met', 'him', 'somewhere', 'before', ',', 'but', 'I', "can't", 'remember', 'where', '.'], answer: "I may have met him somewhere before, but I can't remember where.", explanation: '`may have + 過去分詞` で「〜したかもしれない」という過去の推量を表します。' },

            // Stage 1, Lesson 3 (Passive Voice)
            { type: 'mcq', japanese: '「そのボイラーは今、技術者によってチェックされています。」', question: 'The boiler is now {blank} by an engineer.', options: ['being checked', 'checked', 'checking'], answer: 'being checked', explanation: '「今〜されている最中だ」という進行中の受け身は、現在進行形の受動態 `is being + 過去分詞` で表します。' },
            { type: 'mcq', japanese: '「次の大会は5月27日に開催されます。」', question: 'The next competition {blank} on May 27.', options: ['will be held', 'holds', 'will hold'], answer: 'will be held', explanation: '未来の予定について「〜されるでしょう」と受け身で言うので、未来形の受動態 `will be + 過去分詞` を使います。' },
            { type: 'mcq', japanese: '「その賞はエリザベスに与えられた。」', question: 'A new car {blank} to Elizabeth.', options: ['was given', 'gave', 'giving'], answer: 'was given', explanation: 'SVOOの文型 `They gave Elizabeth a new car.` を受動態にした文です。`A new car` が主語なので `was given to Elizabeth` となります。' },
            { type: 'mcq', japanese: '「そのドアは一日中開けておくべきです。」', question: 'This door should {blank} open during the day.', options: ['be kept', 'keep', 'be keeping'], answer: 'be kept', explanation: '`keep + O + C` の文型を受動態にすると `S is kept C` となります。助動詞 `should` があるので `should be kept + C` の形になります。' },
            { type: 'scramble', japanese: '「図書館のカードを持っている人なら誰でも本を借りられます。」', words: ['Books', 'can', 'be', 'borrowed', 'by', 'anyone', 'who', 'has', 'a', 'library', 'card', '.'], answer: 'Books can be borrowed by anyone who has a library card.', explanation: '助動詞 `can` を含む受動態は `can be + 過去分詞` となります。「〜によって」は `by` で表します。' },
            { type: 'scramble', japanese: '「私たちの車は、大雨のためにひどく損傷し、修理されています。」', words: ['Our', 'car', 'is', 'being', 'repaired', 'at', 'the', 'garage', '.'], answer: 'Our car is being repaired at the garage.', explanation: '「今修理されている最中」なので、現在進行形の受動態 `is being repaired` を使います。' },

            // New questions
            { type: 'mcq', japanese: '「鍵が見つからない。家に忘れてきたに違いない。」', question: "I can't find my keys. I {blank} them at home.", options: ['must have left', 'should have left', 'could leave'], answer: 'must have left', explanation: '過去の出来事に対する強い確信（〜したに違いない）は `must have + 過去分詞` で表します。' },
            { type: 'mcq', japanese: '「その問題はすでに解決されました。」', question: 'The problem {blank} already solved.', options: ['has been', 'was', 'is being'], answer: 'has been', explanation: '「すでに〜された」という完了した受け身の動作は、現在完了形の受動態 `has been + 過去分詞` を使います。' },
            { type: 'scramble', japanese: '「あなたは両親の許可なしにそこへ行くべきではない。」', words: ['You', 'should', 'not', 'go', 'there', 'without', 'your', "parents'", 'permission', '.'], answer: "You should not go there without your parents' permission.", explanation: '「〜すべきではない」という助言・忠告は `should not + 動詞の原形` で表します。' },
            { type: 'mcq', japanese: '「彼が真実を知っているはずがない。」', question: "He {blank} know the truth. He wasn't even there.", options: ["can't", 'must not', 'may not'], answer: "can't", explanation: '「〜のはずがない」という強い否定的な推量は `can\'t` を使います。' },
            { type: 'mcq', japanese: '「彼らはその映画にがっかりしたかもしれない。」', question: 'They {blank} have been disappointed with the movie.', options: ['may', 'must', 'should'], answer: 'may', explanation: '過去の推量「〜だったかもしれない」は `may have + 過去分詞` で表します。' },
            { type: 'mcq', japanese: '「この城は17世紀に建てられました。」', question: 'This castle {blank} in the 17th century.', options: ['was built', 'is built', 'has been built'], answer: 'was built', explanation: '`in the 17th century` という明確な過去の時点があるので、過去形の受動態 `was built` を使います。' },
            { type: 'scramble', japanese: '「その会議は来週まで延期されました。」', words: ['The', 'meeting', 'has', 'been', 'put', 'off', 'until', 'next', 'week', '.'], answer: 'The meeting has been put off until next week.', explanation: '「延期された」という結果が現在に影響を及ぼしているので、現在完了形の受動態 `has been put off` を使います。' },
            { type: 'mcq', japanese: '「傘を持っていく必要はなかったのに。雨は降らなかった。」', question: "You {blank} have taken an umbrella. It didn't rain.", options: ["needn't", 'must not', "couldn't"], answer: "needn't", explanation: '「〜する必要はなかったのに（してしまった）」は `needn\'t have + 過去分詞` で表現します。' },
            { type: 'mcq', japanese: '「窓を開けてもよろしいでしょうか？」', question: '{blank} I open the window?', options: ['May', 'Must', 'Will'], answer: 'May', explanation: '`May I...?` は「〜してもよろしいですか」という丁寧な許可を求める表現です。' },
            { type: 'mcq', japanese: '「その知らせを聞いたとき、彼はショックを受けたに違いない。」', question: 'He {blank} have been shocked when he heard the news.', options: ['must', 'can', 'should'], answer: 'must', explanation: '過去の出来事への強い確信「〜だったに違いない」は `must have + 過去分詞` を使います。' },
            { type: 'mcq', japanese: '「このコンピュータは修理される必要があります。」', question: 'This computer needs {blank}.', options: ['to be repaired', 'repairing', 'repaired'], answer: 'to be repaired', explanation: '`need to be + 過去分詞` または `need + 動名詞` で「〜される必要がある」という意味になります。この選択肢では `to be repaired` が正解です。`repairing` も文法的には可能ですが、選択肢にないためこちらを選びます。' },
            { type: 'scramble', japanese: '「彼女はクラスのみんなに笑われた。」', words: ['She', 'was', 'laughed', 'at', 'by', 'everyone', 'in', 'the', 'class', '.'], answer: 'She was laughed at by everyone in the class.', explanation: '`laugh at` のような句動詞を受動態にする場合、前置詞 `at` を忘れないように注意が必要です。' }
        ];

        const startScreen = document.getElementById('start-screen');
        const quizScreen = document.getElementById('quiz-screen');
        const resultScreen = document.getElementById('result-screen');
        const startBtn = document.getElementById('start-btn');
        const questionCounter = document.getElementById('question-counter');
        const scoreDisplay = document.getElementById('score');
        const progressBar = document.getElementById('progress-bar');
        const japanesePrompt = document.getElementById('japanese-prompt');
        const questionArea = document.getElementById('question-area');
        const optionsContainer = document.getElementById('options-container');
        const scrambleArea = document.getElementById('scramble-area');
        const answerZone = document.getElementById('answer-zone');
        const wordBank = document.getElementById('word-bank');
        const feedback = document.getElementById('feedback');
        const nextBtn = document.getElementById('next-btn');
        const restartBtn = document.getElementById('restart-btn');

        let quizData = [];
        let currentQuestionIndex = 0;
        let score = 0;
        let draggedItem = null;

        startBtn.addEventListener('click', startQuiz);
        nextBtn.addEventListener('click', nextQuestion);
        restartBtn.addEventListener('click', restartQuiz);
        
        function startQuiz() {
            // Shuffle all questions and pick the first 10
            const shuffled = allQuizData.sort(() => 0.5 - Math.random());
            quizData = shuffled.slice(0, 10);

            startScreen.classList.add('hidden');
            resultScreen.classList.add('hidden');
            quizScreen.classList.remove('hidden');
            currentQuestionIndex = 0;
            score = 0;
            scoreDisplay.textContent = score;
            displayQuestion();
        }

        function displayQuestion() {
            resetState();
            const question = quizData[currentQuestionIndex];
            
            questionCounter.textContent = `問題 ${currentQuestionIndex + 1} / ${quizData.length}`;
            progressBar.style.width = `${((currentQuestionIndex + 1) / quizData.length) * 100}%`;
            japanesePrompt.textContent = question.japanese;

            if (question.type === 'mcq') {
                optionsContainer.classList.remove('hidden');
                scrambleArea.classList.add('hidden');
                questionArea.innerHTML = question.question.replace('{blank}', '<span class="font-bold text-blue-500">＿＿＿</span>');
                
                question.options.forEach(option => {
                    const button = document.createElement('button');
                    button.textContent = option;
                    button.classList.add('w-full', 'border-2', 'border-slate-300', 'text-slate-700', 'font-semibold', 'py-3', 'px-4', 'rounded-lg', 'transition', 'duration-200', 'ease-in-out', 'hover:bg-blue-50', 'hover:border-blue-400');
                    button.addEventListener('click', () => checkMCQAnswer(option));
                    optionsContainer.appendChild(button);
                });

            } else if (question.type === 'scramble') {
                optionsContainer.classList.add('hidden');
                scrambleArea.classList.remove('hidden');
                questionArea.textContent = '語順を並べ替えてください。';
                
                const shuffledWords = [...question.words].sort(() => Math.random() - 0.5);
                shuffledWords.forEach(word => {
                    const wordDiv = createWordDiv(word);
                    wordBank.appendChild(wordDiv);
                });
            }
        }
        
        function createWordDiv(word) {
            const wordDiv = document.createElement('div');
            wordDiv.textContent = word;
            wordDiv.classList.add('draggable-item', 'bg-white', 'border', 'border-slate-300', 'rounded-md', 'px-3', 'py-1', 'shadow-sm');
            wordDiv.draggable = true;
            
            // Mouse events
            wordDiv.addEventListener('dragstart', handleDragStart);
            wordDiv.addEventListener('dragend', handleDragEnd);
            
            // Touch events
            wordDiv.addEventListener('touchstart', handleTouchStart, { passive: false });
            wordDiv.addEventListener('touchmove', handleTouchMove, { passive: false });
            wordDiv.addEventListener('touchend', handleTouchEnd, { passive: false });
            
            return wordDiv;
        }

        function handleDragStart(e) {
            draggedItem = e.target;
            setTimeout(() => e.target.classList.add('dragging'), 0);
        }

        function handleDragEnd(e) {
            draggedItem.classList.remove('dragging');
            draggedItem = null;
        }

        // Touch event handlers for mobile support
        let touchOffset = { x: 0, y: 0 };
        let touchTarget = null;
        let originalPosition = null;

        function handleTouchStart(e) {
            e.preventDefault();
            touchTarget = e.target;
            draggedItem = e.target;
            
            const touch = e.touches[0];
            const rect = touchTarget.getBoundingClientRect();
            touchOffset.x = touch.clientX - rect.left;
            touchOffset.y = touch.clientY - rect.top;
            
            // Store original position
            originalPosition = {
                parent: touchTarget.parentNode,
                nextSibling: touchTarget.nextSibling
            };
            
            touchTarget.classList.add('touch-active', 'dragging');
            touchTarget.style.position = 'fixed';
            touchTarget.style.zIndex = '1000';
            touchTarget.style.pointerEvents = 'none';
            updateTouchPosition(touch);
        }

        function handleTouchMove(e) {
            e.preventDefault();
            if (!touchTarget) return;
            
            const touch = e.touches[0];
            updateTouchPosition(touch);
            
            // Check drop zones
            const elementBelow = document.elementFromPoint(touch.clientX, touch.clientY);
            const dropZone = elementBelow?.closest('.drop-zone') || elementBelow?.closest('#word-bank');
            
            // Visual feedback for drop zones
            document.querySelectorAll('.drop-zone, #word-bank').forEach(zone => {
                zone.classList.remove('drop-zone-hover');
            });
            
            if (dropZone) {
                dropZone.classList.add('drop-zone-hover');
            }
        }

        function handleTouchEnd(e) {
            e.preventDefault();
            if (!touchTarget) return;
            
            const touch = e.changedTouches[0];
            const elementBelow = document.elementFromPoint(touch.clientX, touch.clientY);
            const dropZone = elementBelow?.closest('.drop-zone') || elementBelow?.closest('#word-bank');
            
            // Reset styles
            touchTarget.classList.remove('touch-active', 'dragging');
            touchTarget.style.position = '';
            touchTarget.style.zIndex = '';
            touchTarget.style.pointerEvents = '';
            touchTarget.style.left = '';
            touchTarget.style.top = '';
            
            // Remove hover effects
            document.querySelectorAll('.drop-zone, #word-bank').forEach(zone => {
                zone.classList.remove('drop-zone-hover');
            });
            
            // Handle drop
            if (dropZone && dropZone !== touchTarget.parentNode) {
                dropZone.appendChild(touchTarget);
                checkScrambleAnswer();
            } else if (!dropZone) {
                // Return to original position if dropped outside valid zone
                if (originalPosition.nextSibling) {
                    originalPosition.parent.insertBefore(touchTarget, originalPosition.nextSibling);
                } else {
                    originalPosition.parent.appendChild(touchTarget);
                }
            }
            
            touchTarget = null;
            draggedItem = null;
            originalPosition = null;
        }

        function updateTouchPosition(touch) {
            if (!touchTarget) return;
            
            touchTarget.style.left = (touch.clientX - touchOffset.x) + 'px';
            touchTarget.style.top = (touch.clientY - touchOffset.y) + 'px';
        }

        answerZone.addEventListener('dragover', e => { e.preventDefault(); });
        wordBank.addEventListener('dragover', e => { e.preventDefault(); });
        
        answerZone.addEventListener('drop', e => {
            e.preventDefault();
            if (draggedItem) {
                answerZone.appendChild(draggedItem);
                checkScrambleAnswer();
            }
        });
        
        wordBank.addEventListener('drop', e => {
            e.preventDefault();
            if (draggedItem) {
                wordBank.appendChild(draggedItem);
                checkScrambleAnswer();
            }
        });

        function checkMCQAnswer(selectedOption) {
            const question = quizData[currentQuestionIndex];
            const isCorrect = selectedOption === question.answer;

            if (isCorrect) {
                score++;
                scoreDisplay.textContent = score;
                feedback.textContent = '正解！';
                feedback.classList.remove('bg-red-100', 'text-red-700');
                feedback.classList.add('bg-green-100', 'text-green-700');
            } else {
                feedback.textContent = `不正解... 正解は「${question.answer}」`;
                feedback.classList.remove('bg-green-100', 'text-green-700');
                feedback.classList.add('bg-red-100', 'text-red-700');
            }

            feedback.innerHTML += `<br><span class="text-sm font-normal text-slate-600">${question.explanation}</span>`;
            feedback.classList.remove('hidden');
            
            Array.from(optionsContainer.children).forEach(button => {
                button.disabled = true;
                if (button.textContent === question.answer) {
                    button.classList.add('bg-green-200', 'border-green-400');
                } else {
                    button.classList.add('opacity-50');
                }
            });

            nextBtn.classList.remove('hidden');
        }
        
        function checkScrambleAnswer() {
            if (wordBank.children.length > 0) return; 

            const question = quizData[currentQuestionIndex];
            const userAnswer = Array.from(answerZone.children).map(child => child.textContent).join(' ').replace(/ ([.?!,;])$/, '$1');
            const isCorrect = userAnswer === question.answer;

            if (isCorrect) {
                score++;
                scoreDisplay.textContent = score;
                feedback.textContent = '正解！';
                feedback.classList.remove('bg-red-100', 'text-red-700');
                feedback.classList.add('bg-green-100', 'text-green-700');
                answerZone.classList.remove('border-slate-300');
                answerZone.classList.add('border-green-400', 'bg-green-50');
            } else {
                feedback.textContent = `不正解！`;
                feedback.classList.remove('bg-green-100', 'text-green-700');
                feedback.classList.add('bg-red-100', 'text-red-700');
                answerZone.classList.remove('border-slate-300');
                answerZone.classList.add('border-red-400', 'bg-red-50');
            }
            
            feedback.innerHTML += `<br><span class="text-sm font-normal text-slate-600">正解: ${question.answer}<br>${question.explanation}</span>`;
            feedback.classList.remove('hidden');

            Array.from(answerZone.children).forEach(child => child.draggable = false);
            Array.from(wordBank.children).forEach(child => child.draggable = false);

            nextBtn.classList.remove('hidden');
        }

        function nextQuestion() {
            currentQuestionIndex++;
            if (currentQuestionIndex < quizData.length) {
                displayQuestion();
            } else {
                showResults();
            }
        }
        
        function showResults() {
            quizScreen.classList.add('hidden');
            resultScreen.classList.remove('hidden');
            
            document.getElementById('final-score').textContent = score;
            document.getElementById('total-questions').textContent = quizData.length;

            const percentage = (score / quizData.length) * 100;
            const message = percentage === 100 ? '素晴らしい！全問正解です！' :
                            percentage >= 80 ? 'おしい！あと少しです！' :
                            percentage >= 50 ? 'よくできました！' :
                            'もう一度挑戦してみましょう！';
            document.getElementById('result-message').textContent = message;
        }

        function restartQuiz() {
            startScreen.classList.remove('hidden');
            resultScreen.classList.add('hidden');
        }

        function resetState() {
            feedback.classList.add('hidden');
            nextBtn.classList.add('hidden');
            optionsContainer.innerHTML = '';
            wordBank.innerHTML = '';
            answerZone.innerHTML = '';
            answerZone.classList.remove('border-green-400', 'bg-green-50', 'border-red-400', 'bg-red-50');
            answerZone.classList.add('border-slate-300');
        }
    </script>
</body>
</html>